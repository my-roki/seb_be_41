# be-sprint-lol_program

# **[실습] 개요**

🕹️ **텍스트 RPG 게임 프로그램 만들기**
거대한 세계관과 화려한 그래픽을 갖고 있는 지금의 게임은 과거 **TRPG 시절**로 올라가게 됩니다. 게임을 수행하는 사용자들은 `텍스트 기반`으로 캐릭터의 이름, 공격력, 방어력, 체력 등을 직접 입력하며 상대방과 겨루거나 혹은 **`텍스트 기반`**의 모험 시나리오를 진행하게 됩니다.
**본 `예제`**는 과거 **`TRPG`** 일부를 재현해 보도록 하겠습니다.

# **🖥 [텍스트 스타크래프트 프로그램 ] 출력 예시**

```
[안내] TRPG 스타크래프트 시작합니다.
[안내] 자신의 유닛 정보를 입력해 주세요.
[시스템] 유닛 [이름] 을 입력해 주세요 :레이스
[시스템] 유닛 [공격력] 을 입력해 주세요 : (Ex 50)50
[시스템] 유닛 [방어력] 을 입력해 주세요 : (Ex 1)1
[시스템] 유닛 [체력] 을 입력해 주세요 : (Ex 100)100

[안내] 생성된 유닛 정보는 다음과 같습니다.
[안내] 레이스 유닛이 게임에 참여하였습니다.
[공격력] : 50
[방어력] : 1
[체력] : 100
========================================
[안내] 상대 유닛 정보를 입력해 주세요.
[시스템] 유닛 [이름] 을 입력해 주세요 :히드라
[시스템] 유닛 [공격력] 을 입력해 주세요 : (Ex 50)50
[시스템] 유닛 [방어력] 을 입력해 주세요 : (Ex 1)1
[시스템] 유닛 [체력] 을 입력해 주세요 : (Ex 100)100

[안내] 생성된 유닛 정보는 다음과 같습니다.
[안내] 히드라 유닛이 게임에 참여하였습니다.
[공격력] : 50
[방어력] : 1
[체력] : 100
========================================
----------------------------------------
[안내] [레이스]유닛이 [공격] 하였습니다.
[안내] 상대 유닛의 남은 [체력]은 50 입니다.
----------------------------------------
[안내] [레이스]유닛이 [공격] 하였습니다.
[안내] 상대 유닛의 남은 [체력]은 0 입니다.
----------------------------------------
[안내] 더 이상 공격할 수 없습니다.

[안내] 상대 유닛이 제거되었습니다.
```

# **👾 [블리자드]에서 보내준 프로그래밍 요청서**

---

✏️ **[TRPG 프로그램 기능]
본 프로그램은 아래와 같이 `네 가지 기능` 을 추가해 주세요.**

1. `나의 유닛`과 `상대 유닛`의 **정보**를 직접 입력할 수 있도록 해주세요.
2. `입력된 정보`는 `출력`하여 확인할 수 있도록 해주세요.
3. `공격 기능`은 꼭 넣어주세요.
4. 체력이 `0` 이하로 떨어지면 `게임이 종료`되도록 해주세요.

# **🛠 [코드스테이츠]에서 내려온 프로그래밍 참고사항**

⚙ **위 내용은 어떻게 코딩할 수 있을까요?**

▼ **[ 1 단계 ] 프로그램에 필요한 `기능`들 생각해 보기**

프로그램을 제작하기 전 `어떠한 기능`들이 있는지 생각해봅니다. `기능 구현 난이도`를 생각하며 정렬해봅시다.

`유닛 생산` → `유닛 정보 확인` → `유닛 공격`

`#입력` `#출력` `#메서드` `#변수타입 전환` `#공격 정책(연산)`

▼ **[ 2 단계 ] 프로그램에 필요한 `기능` 혹은 적용하고 싶은 개념들을 사전 학습하기**

해당 프로그램에서는 `this` 라는 개념을 공부하고 적용해 보도록 하겠습니다.

# **🤔 this ?**

📚 `클래스의 외부`에서 멤버(필드, 메서드, 이너 클래스)를 호출하기 위해서는 객체를 먼저 생성한 후 ‘`참조 변수명.맴버명`'의 형태로 호출하지만, `클래스 내부`에서는 객체의 생성 없이 필드와 메서드를 바로 사용할 수 있다고 했습니다.

하지만 모든 사용할 수 있는 상태의 맴버는 항상 `객체 속`에만 존재합니다.
그렇다면 어떻게 클래스 내부에서는 `객체를 생성하지 않고 바로 필드와 메서드를 사용`할 수 있을까요?

💡 **내부 객체 참조 변수명인 this 키워드**

우리는 클래스 내부에서도 **객체 안의 멤버를 사용**해 왔습니다. 즉, ‘`참조 변수명.멤버명`’의 형태를 사용해 온 셈입니다. 다만 **객체를 직접 만들지 않은 것** 뿐입니다.

모든 **메서드**에는 **자신이 포함된 클래스의 객체를 가리키는 `this` 라는 참조 변수**가 있습니다.

모든 맴버는 객체 속에 존재하는 것이므로 우리가 `int m = 3` 이라는 필드를 클래스 내부에서 출력하고자 할 때도 `System.out.println(this.m)` 과 같이 작성해야 합니다. 다만 `this.`를 **생략**하면 컴파일러가 **자동**으로 `this.`를 추가해 주기 때문에 지금까지 클래스 내부에서 필드와 메서드를 그대로 사용할 수 있던 것입니다. 지역 변수는 맴버가 아니므로 `this.` 가 자동으로 붙지 않습니다.

📚 **예제 코드를 통해 공부해 보기**

```java
package TestPackage.pack06;

class A{
    // 변수(m,n)를 선언합니다.
    // 현재 아래 변수에는 아무 값이 들어있지 않습니다.
    int m,n;

    // init() 메서드 선언
    // int 타입의 a, b를 전달받습니다.
    void init(int a, int b) {
        // 넘겨 받은 a,b 값을 위에 정의된 필드 m과 n에 대입합니다.
        this.m = a;
        this.n = b;
    }

    // work() 메서드 선언
    // 본 클래스에 있는 메서드를 호출 합니다.
    void work() {
        // 내부 클래스의 init() 메서드 호출
        this.init(2, 3);
    }
}
public class This_ex {
    public static void main(String[] args) {
        // A 클래스 객체 생성
        A a = new A();
        System.out.println(a.m); // 0
        System.out.println(a.n); // 0
        // a 객체의 work() 메서드 출력
        a.work();
        System.out.println(a.m); // 2
        System.out.println(a.n); // 3
    }
}
```

또한 `work()` 메서드에서는 `init()` 메서드를 호출했습니다. 이렇게 클래스 내부에서 맴버인 필드와 메서드를 호출할 때 실제로는 `this.m`, `this.n` 그리고 `this.init()` 와 같이 표현돼야 하며, `this.` 를 생략했을 때 자동으로 추가되는 것입니다.
이상의 내용을 다시한번 정리하면 모든 맴버는 활용할 때 소속과 함께 표기해야 하며, 클래스 내부에서 맴버를 활용할 때 소속을 표기하지 않으면 컴파일러가 자동으로 `this.` 를 붙여 줍니다.
`this.` 를 생략해도 항상 컴파일러가 추가해 주므로 굳이 신경 쓸 필요가 없어 보이지만,
그렇지 않습니다. `this.`를 **명시적으로 붙여줘야 할 때**가 있기 때문입니다.
필드명은 `m`, `n` 이며 `init(int m, int n)` 메서드에도 지역 변수 `m`과 `n` 이 있습니다. `init()` 메서드에서는 입력받은 지역 변수 `m`과 `n`의 값을 필드 `m`과 `n`에 각각 대입하고자 합니다. 먼저 **필드와 지역 변수의 사용 범위**를 알아보겠습니다.
필드 `m`, `n`은 **클래스 내부에 선언**돼 있으며, **클래스 전체에서 사용**할 수 있습니다. 반면 `init()` 메서드에서 선언된 지역 변수 `m`, `n`은 `init()` 메서드 내부에서만 사용할 수 있습니다.
따라서 `init()` **메서드 내부**에서는 필드 `m`, `n`과 지역 변수 `m`, `n` 을 모두 사용할 수 있게 됩니다. 그렇다면 `init()` 메서드 내부에서 필드 `m`, `n` 을 사용하면 이는 `지역변수` 일까요 `필드` 일까요?
지역 변수와 필드 모두를 사용할 수 있는 영역에서는 사용 범위가 좁은 변수, 즉 **지역 변수**로 인식합니다. 따라서 `init()` 메서드 안에서 `m = m`, `n = n` 과 같이 작성하면 컴파일러는 이들 모두를 **지역 변수로 인식**하므로 `this.`는 당연히 추가되지 않을 것입니다.

```java
package TestPackage.pack06;

class A{
    // 필드 생성
    int m,n;

    // 메서드 생성
    void init(int m, int n) {
        // 매개변수는 지역변수에 할당되어 집니다.
        // 즉 init() 에서만 사용 가능
        m = m;
        n = n;
    }
}

public class This_ex {
    public static void main(String[] args) {
        // 필드명과 지역 변수명이 같고, this 키워드를 사용하지 않음.
        // 필드는 값을 초기화 하지 않을 때 JVM이 강제 값 초기화(0).

        // 객체 생성
        A a = new A();
        // 객체의 m, n을 출력(현재 초기화만 진행)
        System.out.println(a.m); // 0
        System.out.println(a.n); // 0

        // init()메서드에 2와 3을 각각 할당
        // 해당 값은 메서드에서만 활용가능
        a.init(2, 3);
        // 우리가 호출한 값은 클래스 내부에 있는 필드값.
        System.out.println(a.m); // 0
        System.out.println(a.n); // 0
    }
}
```

지역 변수에 지역 변수값을 다시 대입하는 형태이므로 **필드값은 전혀 변화가 없습니다.** 따라서 다음과 같이 객체를 생성한 후 메서드를 호출하고 필드값을 확인하면 모두 값이 `0`으로 나옵니다.
따라서 의도한 바와 같이 넘겨 받은 지역 변수 `m`, `n`의 값을 필드 `m`, `n` 에 대입하기 위해서는 다음과 같이 `this.m = m`, `this.n = n` 과 같이 필드에 `this.` 를 붙여 표기해야만 합니다.

```java
package package_states;

class B{
	int m;
	int n;
	void init(int m, int n) {
		// 필드에 존재하는 m,n 값에 대입
		this.m = m;
		this.n = n;
	}
}

public class Class_cons {
	public static void main(String[] args) {
		// 필드명과 지역 변수명이 같고, this 키워드를 사용함.
		B b = new B();
		b.init(2, 3);
		System.out.println(b.m); // 2
		System.out.println(b.n); // 3
	}
}
```

이러한 문제점은 **지역 변수**와 **필드명이 동일**하기 때문에 발생합니다. 애초에 이름이 서로 달랐다면 `this.m = m` 과 같이 필드와 지역 변수를 명시적으로 구분할 필요가 없겠지만, 자바에서 제공하는 대부분의 `API`에는 **메서드의 지역 변수명이 필드명과 동일하게 구성**돼 있습니다. 따라서 `this.m = m` 과 같은 표현은 앞으로도 계속 보게 될 형식입니다.

**▼ [3 단계 ] 프로그램의 `순서`를 생각하고 그려보기**

`유닛 생산` → `유닛 정보 확인` → `유닛 공격`

<img src="https://s3.ap-northeast-2.amazonaws.com/urclass-images/Az458XCUVrs0psrfnFScm-1652226403447.png"/>
